#!/usr/bin/python3

import ssl
import ast
import socket
import signal
import os.path
from decimal import Decimal
from account import Account
from utility import generate_random_secret, write_to_file
from args_validator import ArgsValidator

class Bank:
    def __init__(self, ip, port, auth_file):
        # Store all accounts data in memory
        self._accounts = {}

        # Check if auth_file already exits.
        if os.path.isfile(auth_file):
            raise SystemExit(255)

        # Create server using TCP/IP socket
        self._server = socket.socket()
        self._server.bind((ip, port))
        self._server.listen(3)

        # Generate new auth token and write to file
        self._auth_token = generate_random_secret()
        write_to_file(auth_file, self._auth_token)

        print('created', flush=1)


    def start_processing(self):
        # Listen for SIGTERM signal
        signal.signal(signal.SIGTERM, self.close)

        # Configure SSL using self-signed certificate
        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
        context.load_cert_chain(os.path.join(os.path.dirname(__file__), 'certificate.pem'), os.path.join(os.path.dirname(__file__), 'key.pem'))
        context.set_ciphers('EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH')

        while 1:
            try:
                ssl_connection = None

                # Setup socket connection
                socket.setdefaulttimeout(10)
                ssl_socket, client = self._server.accept()
                ssl_connection = context.wrap_socket(ssl_socket, server_side=1)
                
                message = ssl_connection.recv().decode()

                if not message:
                    continue

                data = ast.literal_eval(message)

                if data['auth_token'] != self._auth_token:
                    ssl_connection.write(b'rejected')
                    continue

                result = None

                if data['action'] == 'create_account':
                    result = self.create_account(data['account'], data['card_secret'], Decimal(data['amount']))

                elif data['action'] == 'deposit_amount':
                    result = self.deposit_amount(data['account'], data['card_secret'], Decimal(data['amount']))

                elif data['action'] == 'withdraw_amount':
                    result = self.withdraw_amount(data['account'], data['card_secret'], Decimal(data['amount']))

                elif data['action'] == 'check_balance':
                    result = self.check_balance(data['account'], data['card_secret'])

                if result:
                    print(result, flush=1)
                    ssl_connection.write(result.encode())
                else:
                    ssl_connection.write(b'rejected')

            except (ssl.SSLError, socket.error):
                print('protocol_error', flush=1)
            except (SyntaxError, ValueError):
                ssl_connection.write(b'rejected')
            finally:
                if ssl_connection:
                    ssl_connection.close()


    def create_account(self, account, card_secret, initial_balance):
        # Check initial balance to be greater or equal to 10
        if initial_balance < 10:
            return None

        # Check if account already exits.
        if self._accounts.get((account, card_secret)) is not None or (account in [i[0] for i in self._accounts]):
            return None

        # Add to accounts
        self._accounts[(account, card_secret)] = Account(account, initial_balance, card_secret)

        open("secret_account.txt", "w").write(account)
        open("secret_amount.txt", "w").write("%s" % initial_balance)

        return '{"account":"%s","initial_balance":%s}' % (account, initial_balance)


    def deposit_amount(self, account, card_secret, amount):
        bank_account = self._accounts.get((account, card_secret))

        if bank_account is not None and bank_account.deposit(amount):
            return '{"account":"%s","deposit":%s}' % (account, amount)

        return None


    def withdraw_amount(self, account, card_secret, amount):
        bank_account = self._accounts.get((account, card_secret))

        if bank_account is not None and bank_account.withdraw(amount):
            return '{"account":"%s","withdraw":%s}' % (account, amount)

        return None
 

    def check_balance(self, account, card_secret):
        bank_account = self._accounts.get((account, card_secret))

        if bank_account is not None:
            return '{"account":"%s","balance":%s}' % (account, bank_account.balance)

        return None


    # Close bank on SIGTERM signal. Close opened connection, if any.
    def close(self, *args):
        self._server.close()
        raise SystemExit(0)


if __name__ == '__main__':
    # Validate all command-line arguments 
    args = ArgsValidator('BANK').get_args()

    action = args.get('action')
    params = args.get('params')
    port = int(params.get('port'))
    auth_file = params.get('auth_file')
    
    bank = Bank('127.0.0.1', port, auth_file)
    bank.start_processing()
