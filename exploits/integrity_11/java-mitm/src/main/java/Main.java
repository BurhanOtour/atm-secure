import commandserver.CommandServer;
import models.Done;
import okio.BufferedSink;
import okio.BufferedSource;
import okio.Okio;
import picocli.CommandLine;

import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class Main implements Runnable {

    private static final int BUFFER_SIZE = 1024;

    @CommandLine.Option(names = "-p", defaultValue = "4000")
    int listeningPort;

    @CommandLine.Option(names = "-s", defaultValue = "127.0.0.1")
    String forwardHost;

    @CommandLine.Option(names = "-q", defaultValue = "3000")
    int forwardPort;

    @CommandLine.Option(names = "-c", defaultValue = "127.0.0.1")
    String commandHost;

    @CommandLine.Option(names = "-d", defaultValue = "5000")
    int commandPort;

    private CommandServer commandServer;

    private Interceptor provideInterceptor() {
        return new ReplayInterceptor(() -> {
            try {
                return new Socket(forwardHost, forwardPort);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        },
            Collections.singletonList(1),
            2);
    }

    @Override public void run() {
        commandServer = new CommandServer(commandHost, commandPort);

        ServerSocket serverSocket;
        try {
            serverSocket = new ServerSocket(listeningPort, 100, InetAddress.getByName("0.0.0.0"));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            try {
                serverSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }));

        try {
            Interceptor interceptor = provideInterceptor();

            System.out.println("started");
            while (interceptor.shouldAcceptNextSocket()) {
                interceptor.onBeforeNextAccept();
                try {
                    try (Socket s = serverSocket.accept();
                         Socket forwardSocket = new Socket(forwardHost, forwardPort);
                         BufferedSource in = Okio.buffer(Okio.source(s));
                         BufferedSink out = Okio.buffer(Okio.sink(s));
                         BufferedSource forwardIn = Okio.buffer(Okio.source(forwardSocket));
                         BufferedSink forwardOut = Okio.buffer(Okio.sink(forwardSocket))) {
                        interceptor.onAccepted();

                        List<Thread> threads = Arrays.asList(
                            new Thread(() -> copyAndInterceptLines(interceptor::clientToServer, in, out, forwardOut)),
                            new Thread(() -> copyAndInterceptLines(interceptor::serverToClient, forwardIn, forwardOut, out))
                        );
                        threads.forEach(Thread::start);
                        for (Thread thread : threads) {
                            thread.join();
                        }
                    }
                    interceptor.onSocketClosed();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            interceptor.onProxyClosed();
            sendDoneCommand();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    private void sendDoneCommand() {
        commandServer.send(new Done());
    }

    public static void main(String[] args) {
        CommandLine.run(new Main(), System.out, args);
    }

    interface OneWayInterceptor {
        boolean intercept(byte[] bytes, BufferedSink replySink, BufferedSink forwardSink) throws IOException;
    }

    private static void copyAndInterceptLines(OneWayInterceptor interceptor, BufferedSource in, BufferedSink replySink, BufferedSink forwardSink) {
        try {
            System.err.println("Intercepting");
            byte[] forInterceptor = in.readUtf8Line().getBytes(StandardCharsets.UTF_8);
            boolean keepSocketOpen = interceptor.intercept(forInterceptor, replySink, forwardSink);
            System.err.println("Interception complete");
            if (!keepSocketOpen) {
                try {
                    in.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                try {
                    forwardSink.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static void copyAndIntercept(OneWayInterceptor interceptor, BufferedSource in, BufferedSink replySink, BufferedSink forwardSink) {
        try {
            byte[] buffer = new byte[BUFFER_SIZE];
            while (!in.exhausted()) {
                int readBytes = in.read(buffer);
                byte[] forInterceptor;
                if (readBytes == -1) {
                    break;
                } else if (readBytes != buffer.length) {
                    forInterceptor = Arrays.copyOf(buffer, readBytes);
                } else {
                    forInterceptor = buffer;
                }

                boolean keepSocketOpen = interceptor.intercept(forInterceptor, replySink, forwardSink);
                if (!keepSocketOpen) {
                    try {
                        in.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    try {
                        forwardSink.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    break;
                }
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}