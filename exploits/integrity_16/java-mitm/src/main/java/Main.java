import okhttp3.HttpUrl;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okio.BufferedSink;
import okio.BufferedSource;
import okio.Okio;
import picocli.CommandLine;

import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class Main implements Runnable {

    private static final int BUFFER_SIZE = 1024;
    private static final String REQUEST_DONE_MSG = "{\n" +
        "  \"REQUEST\": \"{\\\"type\\\": \\\"done\\\"\"\n" +
        "}";

    @CommandLine.Option(names = "-p", defaultValue = "4000")
    int listeningPort;

    @CommandLine.Option(names = "-s", defaultValue = "127.0.0.1")
    String forwardHost;

    @CommandLine.Option(names = "-q", defaultValue = "3000")
    int forwardPort;

    @CommandLine.Option(names = "-c", defaultValue = "127.0.0.1")
    String commandHost;

    @CommandLine.Option(names = "-d", defaultValue = "5000")
    int commandPort;

    private Interceptor provideInterceptor() {
        return new ReplayInterceptor(
            () -> {
                try {
                    return new Socket(forwardHost, forwardPort);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            },
            Collections.singletonList(1),
            3,
            2);
    }

    @Override public void run() {
        ServerSocket serverSocket;
        try {
            serverSocket = new ServerSocket(listeningPort, 100, InetAddress.getByName("0.0.0.0"));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            try {
                serverSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }));

        try {
            Interceptor interceptor = provideInterceptor();

            System.out.println("started");
            while (interceptor.shouldAcceptNextSocket()) {
                interceptor.onBeforeNextAccept();
                try {
                    try (Socket s = serverSocket.accept();
                         Socket forwardSocket = new Socket(forwardHost, forwardPort);
                         BufferedSource in = Okio.buffer(Okio.source(s));
                         BufferedSink out = Okio.buffer(Okio.sink(s));
                         BufferedSource forwardIn = Okio.buffer(Okio.source(forwardSocket));
                         BufferedSink forwardOut = Okio.buffer(Okio.sink(forwardSocket))) {
                        interceptor.onAccepted();

                        List<Thread> threads = Arrays.asList(
                            new Thread(() -> copyAndIntercept(interceptor::clientToServer, in, forwardOut)),
                            new Thread(() -> copyAndIntercept(interceptor::serverToClient, forwardIn, out))
                        );
                        threads.forEach(Thread::start);
                        for (Thread thread : threads) {
                            thread.join();
                        }
                    }
                    interceptor.onSocketClosed();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            interceptor.onProxyClosed();
            sendDoneCommand();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    private void sendDoneCommand() {
        HttpUrl url = new HttpUrl.Builder()
            .scheme("http")
            .host(commandHost)
            .port(commandPort)
            .build();
        OkHttpClient httpClient = new OkHttpClient();
        Request request = new Request.Builder()
            .post(RequestBody.create(MediaType.parse("application/json"), REQUEST_DONE_MSG))
            .url(url)
            .build();
        try {
            httpClient.newCall(request).execute();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        CommandLine.run(new Main(), System.out, args);
    }

    interface OneWayInterceptor {
        InterceptionResult intercept(byte[] bytes);
    }

    private static void copyAndIntercept(OneWayInterceptor interceptor, BufferedSource in, BufferedSink out) {
        try {
            byte[] buffer = new byte[BUFFER_SIZE];
            while (!in.exhausted()) {
                int readBytes = in.read(buffer);
                byte[] forInterceptor;
                if (readBytes == -1) {
                    break;
                } else if (readBytes != buffer.length) {
                    forInterceptor = Arrays.copyOf(buffer, readBytes);
                } else {
                    forInterceptor = buffer;
                }

                InterceptionResult result = interceptor.intercept(forInterceptor);
                out.write(result.getNewBytes());
                out.flush();

                if (!result.keepSocketOpen()) {
                    try {
                        in.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    try {
                        out.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    break;
                }
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}